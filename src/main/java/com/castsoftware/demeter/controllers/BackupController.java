/*
 * Copyright (C) 2020  Hugo JOBY
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License v3 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public v3
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

package com.castsoftware.demeter.controllers;

import com.castsoftware.demeter.config.Configuration;
import com.castsoftware.demeter.database.Neo4jAL;
import com.castsoftware.demeter.exceptions.neo4j.Neo4jBadNodeFormatException;
import com.castsoftware.demeter.exceptions.neo4j.Neo4jBadRequestException;
import com.castsoftware.demeter.exceptions.neo4j.Neo4jNoResult;
import com.castsoftware.demeter.exceptions.neo4j.Neo4jQueryException;
import com.castsoftware.demeter.models.BackupNode;
import com.castsoftware.demeter.models.imaging.Level5Node;
import com.castsoftware.demeter.utils.LevelsUtils;
import org.neo4j.graphdb.Direction;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;
import org.neo4j.graphdb.RelationshipType;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class BackupController {

  private static final String BACKED_UP_BY_REL =
      Configuration.get("demeter.backup.relationship.type");
  private static final String AGGREGATES_REL = Configuration.get("imaging.node.level_nodes.links");
  private static final String IMAGING_OBJECT_LABEL = Configuration.get("imaging.node.object.label");
  private static final String IMAGING_LEVEL_5_LABEL =
      Configuration.get("imaging.node.level5.label");
  private static final String IMAGING_AGGREGATES =
      Configuration.get("imaging.node.level_nodes.links");
  private static final String GENERATED_LEVEL_PREFIX =
      Configuration.get("demeter.prefix.generated_level_prefix");

  private static final String ERROR_PREFIX = "BCKUPCx";

  /**
   * Undo all demeter groups in the specified application. The old level 5 will be retrieved.
   *
   * @param neo4jAL Neo4j Application Context
   * @param applicationContext Name of the application
   * @return
   * @throws Neo4jBadRequestException
   * @throws Neo4jQueryException
   * @throws Neo4jNoResult
   * @throws Neo4jBadNodeFormatException
   */
  public static List<Node> undoLevelGroups(Neo4jAL neo4jAL, String applicationContext)
      throws Neo4jBadRequestException, Neo4jQueryException, Neo4jNoResult,
          Neo4jBadNodeFormatException {
    List<Level5Node> backupNodes = new ArrayList<>();

    // Get Level backup nodes
    List<Level5Node> toCheckLevels = new ArrayList<>();
    List<String> deletedLevelName = new ArrayList<>();

    // Delete Demeter level5 group based on their full name
    for (Level5Node level : Level5Node.getAllNodesByApplication(neo4jAL, applicationContext)) {
      String fullName = level.getFullName();

      // If the full name match, the level was generated by Demeter
      if (fullName.matches(".*##(" + GENERATED_LEVEL_PREFIX + ".*)")) {
        // Keep level to reassign nodes later
        deletedLevelName.add(level.getName());
        level.deleteNode();
      } else {
        // Is not a demeter level
        toCheckLevels.add(level);
      }
    }

    // Get all  backup node
    List<BackupNode> backupNodeList =
        BackupNode.getApplicationBackupNode(neo4jAL, applicationContext, IMAGING_LEVEL_5_LABEL);

    // Recreate level 5
    for (BackupNode bkn : backupNodeList) {
      Node n = bkn.startBackup();
      backupNodes.add(Level5Node.fromNode(neo4jAL, n));
    }

    // Relink objects to their parent levels for each deleted level
    // Due to the "Level" Property
    String forgedLabel;
    String forgeRequest;
    for (String levelName : deletedLevelName) {
      forgedLabel = IMAGING_OBJECT_LABEL + ":" + applicationContext;

      // Find nodes with the ancient level 5 name
      forgeRequest =
          String.format(
              "MATCH (o:`%1$s`)<-[:%2$s]-(l:`%3$s`) WHERE o.Level='%4$s' AND NOT l.Name='%4$s' SET o.Level=l.Name;",
              forgedLabel, IMAGING_AGGREGATES, IMAGING_LEVEL_5_LABEL, levelName);
      neo4jAL.executeQuery(forgeRequest);
    }

    // Recount level
    for (Level5Node level : toCheckLevels) {
      LevelsUtils.refreshLevel5(neo4jAL, applicationContext, level.getNode());
    }

    List<Node> returnNodes = new ArrayList<>();
    for (Level5Node level : backupNodes) {
      LevelsUtils.refreshLevel5(neo4jAL, applicationContext, level.getNode());
      returnNodes.add(level.getNode());
    }

    // Refresh abstract levels
    LevelsUtils.refreshAllAbstractLevel(neo4jAL, applicationContext);
    return returnNodes;
  }

  /**
   * Undo only one demeter level
   *
   * @param neo4jAL Neo4j Access Layer
   * @param applicationContext Name of the application where the level is present
   * @param levelName Name of the level to undo
   * @return The list of level 5 nodes re-created
   * @throws Neo4jBadRequestException The Undo produced a bad request
   * @throws Neo4jNoResult The undo operation returned no results
   * @throws Neo4jBadNodeFormatException
   * @throws Neo4jQueryException
   */
  public static List<Node> undoOneLevelGroup(
      Neo4jAL neo4jAL, String applicationContext, String levelName)
      throws Neo4jBadRequestException, Neo4jNoResult, Neo4jBadNodeFormatException,
          Neo4jQueryException {
    RelationshipType backedUpRelationship = RelationshipType.withName(BACKED_UP_BY_REL);
    RelationshipType aggregatesRelationship = RelationshipType.withName(AGGREGATES_REL);
    List<Level5Node> backedNodes = new ArrayList<>();

    // Get Level backup nodes
    List<Level5Node> toCheckLevels = new ArrayList<>();

    Level5Node toTreat = null;
    // Get the level associated with the search
    for (Level5Node level : Level5Node.getAllNodesByApplication(neo4jAL, applicationContext)) {
      String fullName = level.getFullName();

      // If the full name match, the level was generated by Demeter
      if (fullName.matches("(.*)##" + GENERATED_LEVEL_PREFIX + levelName)) {
        // Keep level to reassign nodes later
        toTreat = level;
        break;
      } else {
        // Is not a demeter level
        toCheckLevels.add(level);
      }
    }

    if (toTreat == null) {
      throw new Neo4jBadRequestException(
          String.format("No level with name '%s' found in the database.", levelName),
          ERROR_PREFIX + "UNDOO1");
    }

    List<Node> affectedNode = new ArrayList<>();
    List<Long> visitedBackupNode = new ArrayList<>();
    List<Node> backupNodeSet = new ArrayList<>();

    // Get object links to the level to be deleted and retrieve backup nodes
    for (Iterator<Relationship> it =
            toTreat
                .getNode()
                .getRelationships(Direction.OUTGOING, aggregatesRelationship)
                .iterator();
        it.hasNext(); ) {
      Relationship rel = it.next();

      Node obj = rel.getEndNode();
      affectedNode.add(obj);

      // Get list of backup nodes to trigger
      for (Iterator<Relationship> bckIt =
              obj.getRelationships(Direction.INCOMING, backedUpRelationship).iterator();
          bckIt.hasNext(); ) {
        Relationship relObj = bckIt.next();
        Node bckNode = relObj.getStartNode();

        if (!visitedBackupNode.contains(bckNode.getId())) {
          backupNodeSet.add(bckNode);
          visitedBackupNode.add(bckNode.getId());
        }
      }
    }

    // Delete old level
    toTreat.deleteNode();

    // Launch Backup
    for (Node bkn : backupNodeSet) {
      BackupNode backupNode = BackupNode.fromNode(neo4jAL, bkn);
      Node n = backupNode.startBackup();
      backedNodes.add(Level5Node.fromNode(neo4jAL, n));
    }

    // Recount level
    for (Level5Node level : toCheckLevels) {
      LevelsUtils.refreshLevel5(neo4jAL, applicationContext, level.getNode());
    }

    // Refresh created levels
    List<Node> returnNodes = new ArrayList<>();
    for (Level5Node level : backedNodes) {
      LevelsUtils.refreshLevel5(neo4jAL, applicationContext, level.getNode());
      returnNodes.add(level.getNode());
    }

    // Refresh abstract levels ( Level 4 and superiors)
    LevelsUtils.refreshAllAbstractLevel(neo4jAL, applicationContext);

    return returnNodes;
  }
}
